/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package treerex.hydra;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;

import fr.uga.pddl4j.parser.DefaultParsedProblem;
import fr.uga.pddl4j.parser.ErrorManager;
import fr.uga.pddl4j.parser.Message;
import fr.uga.pddl4j.parser.Parser;
import fr.uga.pddl4j.planners.LogLevel;
import fr.uga.pddl4j.problem.DefaultProblem;
import fr.uga.pddl4j.problem.operator.TaskNetwork;
import treerex.hydra.DataStructures.Layer;
import treerex.hydra.DataStructures.SolverType;
import treerex.hydra.DataStructures.PartialOrder.Solution;
import treerex.hydra.DataStructures.PartialOrder.Tree;
import treerex.hydra.DataStructures.PartialOrder.TreeNode;
import treerex.hydra.Encoder.ProblemEncoder;
import treerex.hydra.Encoder.SATUniqueIDCreator;
import treerex.hydra.EncoderPartialOrder.ProblemEncoderPartialOrder;
import treerex.hydra.Preprocessing.NetworkGenerator;
import treerex.hydra.SolverConfig.SolverConfig;

public class Hydra {

    public static boolean enableDebugOutput = false;
    /**
     * The main method the class. The first argument must be the path to the PDDL
     * domain description and the second
     * argument the path to the PDDL problem description.
     *
     * @param args
     *            the command line arguments.
     */
    public static String projectDir = "";
    public static SolverType solver;
    // Configurations used by the solver
    public static HashSet<SolverConfig> solverConfigs = new HashSet<SolverConfig>();
    public static DefaultProblem problem2;

    public static void main(String[] args) {

        String s = System.getProperty("user.dir");
        projectDir = s.replaceAll("\\\\", "/");
        // Checks the number of arguments from the command line
        // If no arguments - we will run the planner on Transport p0.
        // Useful, if we want to quickly debug the program
        if (args.length == 0) {
            if (Hydra.enableDebugOutput) {
                System.out.println("No args. Running on ipc2020 TO Transport p0");
            }

            String dom = projectDir +
                    "/benchmarks/ipc2020/total-order/Transport/domain.hddl";
            String p = projectDir +
                    "/benchmarks/ipc2020/total-order/Transport/pfile01.hddl";

            /* String dom = projectDir +
                   "/benchmarks/ipc2023/test/transport/transport-04-d.hddl";
            String p = projectDir +
                   "/benchmarks/ipc2023/test/transport/transport-04-p.hddl";*/
            /* String dom = projectDir +
                    "/benchmarks/ipc2023/test/elevators/elevators-01-d.hddl";
            String p = projectDir +
                    "/benchmarks/ipc2023/test/elevators/elevators-01-p.hddl";*/
            /*String dom = projectDir +
                    "/benchmarks/ipc2023/test/monroe/monroe-fo-01-d.hddl";
            String p = projectDir +
                    "/benchmarks/ipc2023/test/monroe/monroe-fo-01-p.hddl";*/
            /* 
            String dom = projectDir +
                    "/benchmarks/ipc2020/total-order/Barman-BDI/domain.hddl";
            String p = projectDir +
                    "/benchmarks/ipc2020/total-order/Barman-BDI/pfile01.hddl";*/

            /*   String dom = projectDir +
              "/benchmarks/ipc2020/total-order/Childsnack/domain.hddl";
              String p = projectDir +
              "/benchmarks/ipc2020/total-order/Childsnack/p01.hddl";
             */
            args = new String[] {
                    "csp",
                    "po",
                    dom,
                    p };
        }
        // Otherwise, we need 2 arguments - domain and proble mpath
        else if (args.length < 4) {
            System.out.println("Error. Need 4 arguments - sat/smt/csp AND to/po AND domainPath AND problemPath");
            return;
        }

        // All further argument will be for the configuration of the solver
        for (int i = 3; i < args.length; i++) {
            for (SolverConfig solverConf : SolverConfig.values()) {
                if (args[i].equalsIgnoreCase(solverConf.name())) {
                    solverConfigs.add(solverConf);
                }
            }
        }

        if (args[0].toLowerCase().equals("csp")) {
            solver = SolverType.CSP;
        } else if (args[0].toLowerCase().equals("smt")) {
            solver = SolverType.SMT;
        } else if (args[0].toLowerCase().equals("sat")) {
            solver = SolverType.SAT;
        }

        boolean isPartialOrder = true;
        if (args[1].toLowerCase().equals("po")) {
            isPartialOrder = true;
        } else if (args[1].toLowerCase().equals("to")) {
            isPartialOrder = false;
        }
        // isPartialOrder = false;

        try {

            // 1. PARSE THE PROBLEM
            // Creates an instance of the PDDL parser
            final Parser parser = new Parser();
            // Disable log
            parser.setLogLevel(LogLevel.OFF);
            // Parses the domain and the problem files.
            final DefaultParsedProblem parsedProblem = parser.parse(args[2], args[3]);
            // Gets the error manager of the parser
            final ErrorManager errorManager = parser.getErrorManager();
            // Checks if the error manager contains errors
            if (!errorManager.isEmpty()) {
                // Prints the errors
                for (Message m : errorManager.getMessages()) {
                    System.out.println(m.toString());
                }
            }
            // Create a problem
            final DefaultProblem problem = new DefaultProblem(parsedProblem);

            // Instantiate the planning problem
            problem.instantiate();

            problem2 = problem;

            // Prints that the domain and the problem were successfully parsed
            if (enableDebugOutput) {
                System.out.print("\nparsing domain file \"" + args[2] + "\" done successfully");
                System.out.print("\nparsing problem file \"" + args[3] + "\" done successfully\n\n");
            }

            if (isPartialOrder == false) {
                // Initialize the class which will allow us to create an unique IDs for each
                // variable
                // (only for SAT)
                if (solver == SolverType.SAT) {
                    SATUniqueIDCreator.initialize(problem);
                }

                // 2. CREATE THE NETWORK
                List<Layer> network = NetworkGenerator.generateInitialNetwork(problem);

                // 3. ENCODE THE PROBLEM
                int timeout = 300000; // timeout
                try {
                    ProblemEncoder.encodeProblemInRows(timeout, network, problem, args);
                } catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            } else if (isPartialOrder) {
                TreeNode root = new TreeNode(problem);

                TreeNode node0 = new TreeNode(problem);
                node0.addPrimitiveAction(problem.getTasks().size());
                TreeNode nodeInfty = new TreeNode(problem);
                nodeInfty.addPrimitiveAction(problem.getTasks().size() + 1);

                List<TreeNode> initialNodes = new ArrayList<>();
                // populate initialNodes with initHTN
                TaskNetwork initHTN = problem.getInitialTaskNetwork();
                List<Integer> initTasks = initHTN.getTasks();

                for (Integer t : initTasks) {
                    TreeNode n = new TreeNode(problem);
                    // if problem is so simple we don't need to do anything, PDDL4J returns null as
                    // task. See ipc2023, robot01
                    if (t != null) {
                        n.addAbstractTask(t);
                        initialNodes.add(n);
                    } else {
                        System.out.println("NOTHING TO DO");
                        System.exit(0);
                    }
                }
                // add dummy nodes
                initialNodes.add(node0);
                initialNodes.add(nodeInfty);
                // set root children
                root.setChildren(initialNodes);

                Tree t = new Tree(root);
                // root.minimalNodeExpand(problem);
                // REMAIN IN EXPAND & SOLVE LOOP UNTIL either solved or can't keep expanding
                boolean updated = true;
                boolean sat = false;
                float planTime = 0;
                float start = System.nanoTime();
                int expansion = 0;
                String solutionPlan = "";
                while (!sat && updated) {
                    // DEBUG LOOP
                    // i < 3 - for Transport 1 (Layers 0, 1 using TO)
                    // i < 7 - for Barman BDI 1 (Layers 0-5 using TO)
                    // i < 7 - for Satellite GTOHP (Layers 0-5 using TO)
                    // for (int i = 0; i < 8; i++) {
                    System.out.println("iteration " + expansion);
                    expansion++;
                    for (TreeNode leaf : t.getLeaves(root)) {
                        boolean res = leaf.minimalNodeExpand(problem);
                        if (res) {
                            updated = true;
                        }
                    }
                    // }
                    // System.out.println("---");
                    // t.printTree(root);
                    // System.out.println(t.getLeaves(root).size());

                    // print just nodes
                    /*
                     * List<TreeNode> nodes = t.getNodes();
                     * String ss = "";
                     * for (TreeNode t2 : nodes) {
                     * ss += " " + t2.getDebugLabel();
                     * }
                     * System.out.println(ss);
                     */

                    Solution solutionInfo = ProblemEncoderPartialOrder.encodeProblem(t, problem);
                    planTime += solutionInfo.getTime();

                    // output solution
                    solutionPlan = solutionInfo.getPlan();
                    if (Hydra.enableDebugOutput) {
                        System.out.println(node0.getID() + " " + nodeInfty.getID());
                    }
                    if (!solutionInfo.getPlan().isEmpty()) {
                        sat = true;
                    }
                }
                System.out.println(solutionPlan);
                System.out.println("totalTime=" + (System.nanoTime() - start) / 1_000_000_000);
                System.out.println("planTime=" + planTime);

                if (enableDebugOutput) {
                    if (sat) {
                        System.out.println("we are SAT");
                    } else {

                        System.out.println("we are UNSAT");
                    }
                }
            }

            // This exception could happen if the domain or the problem does not exist
        } catch (Throwable t) {
            t.printStackTrace();
        }
    }
}
